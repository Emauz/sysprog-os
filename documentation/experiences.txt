The first thing we did when starting our project was design what features we wanted each module to
include. For our three projects we decided they should do the following:

Ethernet driver: 
    -provide direct control of the card
    -have transmit and receive commands
    -be non-blocking

Headers:
    -be able to create UDP, IPv4, and UDP headers

Syscalls:
    -provide a way for the user to send and receive data

We also discussed how data should be passed between these projects. One idea was to have the syscall
handle the user data, pass it to the headers module, which then passes the assembled packet to the
ethernet module. We ended up deciding that the syscalls module should handle user data, use the headers
module as a library to add a header onto data managed by the syscalls module, then the ethernet module
copies that data to manage it itself. This proved easier to manage since the lifetime of the data was
different for each layer, e.g. the user data doesn't need to be tracked after the command is sent to
the ethernet module.

We started by implementing the ethernet driver and tried to add functionality as to what we initially
intended. We were able to have commands for setting the MAC address, transmitting, but in order to have
non-blocking receiving we couldn't use a function call into the ethernet module. We ended up using the
idea of callback functions so the ethernet module can "hook" into higher modules it doesn't need know
about.

After this was implemented the headers module and syscalls projects were able to use the functions it
provided to directly control the hardware.


==== PROBLEMS FACED -- SARAH ====

========

==== PROBLEMS FACED -- ERIC ====

One challenge I faced was handling processes while the card was actively processing a command. Each
process that was actively waiting for a send or recieve command to complete needed to be queued up 
and properly restarted once the job was completed. 

For sends and other jobs executed on the command unit, this was handled in a way that worked well 
for the level of resiliency we wanted in our project. When the CU completed a command and the syscall
layer had finished handling it, it would call back up to the top layer with the ID that was completed.
Our error checking was to ensure that this ID matches the PID of the process we're expecting, and if
that works out, we go ahead and re-schedule that process.

For recieves, the process was a little bit more complex. Since we could have multiple or zero processes 
waiting on a single port, we just brute force scanned all waiting processes to see which ones were
expecting data on that port, and copied in the recieved data for all of them. This meant that we
had to have a static number of possible recieving processes, as we didn't implement dynamic memory 
allocation, but for the scope of this process, that worked well enough for us.

=======


==== PROBLEMS FACED -- WILL ====

=======
